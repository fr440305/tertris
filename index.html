<!doctype html>
<!--

Reference: https://harddrop.com/wiki/Tetris_Wiki

-->

<html>
<head>

<meta charset="utf8">
<meta name="viewport" content="width=device-width; initial-scale=1.0">

<style>

#GameContainer {
	display: grid;
	margin-top: 80px;
	place-items: center;
}
#GameMatrix {
	border: 2px solid black;
	border-radius: 5px;
	padding: 3px;
	display: table;
	background: #fff;
}
#GameMatrix>div {
	display: table-row;
}
#GameMatrix>div>div {
	display: table-cell;
	width: 20px;
	height: 20px;
	border: 2px solid white;
}

#GameMatrix>div>div.active-I {
	background-image: linear-gradient(to bottom right, white, cyan);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: cyan;
	border-right-color: cyan;
} #GameMatrix>div>div.locked-I {
	background: cyan;
	border-color: cyan;
}

#GameMatrix>div>div.active-O {
	background-image: linear-gradient(to bottom right, white, yellow);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: yellow;
	border-right-color: yellow;
} #GameMatrix>div>div.locked-O {
	background: yellow;
	border-color: yellow;
}

#GameMatrix>div>div.active-T {
	background-image: linear-gradient(to bottom right, white, purple);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: purple;
	border-right-color: purple;
} #GameMatrix>div>div.locked-T {
	background: purple;
	border-color: purple;
}

#GameMatrix>div>div.active-S {
	background-image: linear-gradient(to bottom right, white, green);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: green;
	border-right-color: green;
} #GameMatrix>div>div.locked-S {
	background: green;
	border-color: green;
}

#GameMatrix>div>div.active-Z {
	background-image: linear-gradient(to bottom right, white, red);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: red;
	border-right-color: red;
} #GameMatrix>div>div.locked-Z {
	background: red;
	border-color: red;
}

#GameMatrix>div>div.active-J {
	background-image: linear-gradient(to bottom right, white, blue);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: blue;
	border-right-color: blue;
} #GameMatrix>div>div.locked-J {
	background: blue;
	border-color: blue;
}

#GameMatrix>div>div.active-L {
	background-image: linear-gradient(to bottom right, white, orange);
	border-top-color: white;
	border-left-color: white;
	border-bottom-color: orange;
	border-right-color: orange;
} #GameMatrix>div>div.locked-L {
	background: orange;
	border-color: orange;
}

#DebugElement {
	border: 2px solid red;
	padding: 5px;
}
</style>
</head>

<body>

<div id='GameContainer'>
	<div id='GameMatrix' data-matrix-size='20x10'>
	</div>

	<pre id='DebugElement'>hello, world</pre>
</div>


<script>

function newMatrix(rowSize, colSize, initValue) {
	let ret = [];

	for (let r = 0; r < rowSize; r++) {
		ret[r] = [];
		for (let c = 0; c < colSize; c++) {
			ret[r][c] = initValue;
		}
	}

	return ret;
}

const TETRIMINOS = {
	I: [
		0, 0, 0, 0,
		1, 1, 1, 1,
		0, 0, 0, 0,
		0, 0, 0, 0
	],
	O: [
		0, 0, 0, 0,
		0, 1, 1, 0,
		0, 1, 1, 0,
		0, 0, 0, 0
	],
	T: [
		0, 1, 0,
		1, 1, 1,
		0, 0, 0
	],
	S: [
		0, 1, 1,
		1, 1, 0,
		0, 0, 0
	],
	Z: [
		1, 1, 0,
		0, 1, 1,
		0, 0, 0
	],
	J: [
		1, 0, 0,
		1, 1, 1,
		0, 0, 0
	],
	L: [
		0, 0, 1,
		1, 1, 1,
		0, 0, 0
	]
};

const L33 = [2, 5, 8, 1, 4, 7, 0, 3, 6]; 
const R33 = [6, 3, 0, 7, 4, 1, 8, 5, 2]; 
const L44 = [3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12]; 
const R44 = [12, 8, 4, 0, 13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3];

function GameState(rowSize, colSize, elapsed) {
	this.elapsed = elapsed;

	this.currentTetrimino = {
		r: 4,
		c: 4,
		type: 'Z',
		mat: TETRIMINOS['Z']
	};
	this.rowSize = rowSize;
	this.colSize = colSize;

	// From pause to continue: 3, 2, 1, Go!
	this.isPaused = false; 
	this.isGameOver = false;

	this.tsLastContinue = 0;
	this.tsLastGameOver = 0;
	this.tsLastSoftDrop = 0;
	this.tsLastFallen = 0;
	this.tsLastLocked = 0;
	this.tsLastSpawned = 0;

	this.historyTetriminos = newMatrix(this.rowSize, this.colSize, 0);
	this.upcomingTetriminoTypes = [];
}

GameState.prototype.setPauseStatus = function(command, ts) {
	switch (command) {
		case 'pause':
			this.isPaused = true;
			break;
		case 'cont':
			this.isPaused = false;
			this.tsLastContinue = ts;
			break;
		case 'toggle':
			if (this.isPaused) {
				this.tsLastContinue = ts;
			}
			this.isPaused = !this.isPaused;
			break;
	}
}

GameState.prototype._isOverlappedWithFloor = function(tetrimino, history, rowSize, colSize) {
	let tetriminoMatrixSize = (tetrimino.mat.length === 16) ? 4 : 3;
	for (let r = 0; r < tetriminoMatrixSize; r++) {
		for (let c = 0; c < tetriminoMatrixSize; c++) {
			if (tetrimino.mat[r * tetriminoMatrixSize + c] === 1) {
				let realR = tetrimino.r + r;
				let realC = tetrimino.c + c;

				if (
					realR === rowSize ||
					history[realR][realC] === 1
				) {
					return true;
				}
			}
		}
	}

	return false;
}

GameState.prototype._isHittedIntoWall = function(tetrimino, colSize) {
	let tetriminoMatrixSize = (tetrimino.mat.length === 16) ? 4 : 3;
	for (let r = 0; r < tetriminoMatrixSize; r++) {
		for (let c = 0; c < tetriminoMatrixSize; c++) {
			if (tetrimino.mat[r * tetriminoMatrixSize + c] === 1) {
				let realR = tetrimino.r + r;
				let realC = tetrimino.c + c;
				
				if (realC < 0 || realC >= colSize) {
					return true;
				}
			}
		}
	}

	return false;
}

GameState.prototype.moveCurrentTetrimino = function(direction, ts) {
	//
	// @Todo. Shoud make move, spin,
	// and harddrop private and being
	// called by operateCurrentTetrimino.
	// So that we don't have to check
	// this.isPaused || this.isGameOver || etc
	// every time. --wshtan, 31 Aug 2020.
	//
	if (this.isPaused || this.isGameOver) {
		return;
	}

	let nextR = this.currentTetrimino.r;
	let nextC = this.currentTetrimino.c;

	if (direction === 'l') {
		nextC -= 1;
		if (this._isHittedIntoWall({
			r: nextR,
			c: nextC,
			type: this.currentTetrimino.type,
			mat: this.currentTetrimino.mat
		}, this.colSize)) {
			console.log('??????');
			return false;
		} else {
			this.currentTetrimino.c = nextC;
		}
	} else if (direction === 'r') {
		nextC += 1;
		if (this._isHittedIntoWall({
			r: nextR,
			c: nextC,
			type: this.currentTetrimino.type,
			mat: this.currentTetrimino.mat
		}, this.colSize)) {
			console.log('??????');
			return false;
		} else {
			this.currentTetrimino.c = nextC;
		}
	} else if (direction === 'd') {
		nextR += 1;
		if (this._isOverlappedWithFloor(
			{
				r: nextR,
				c: nextC,
				type: this.currentTetrimino.type,
				mat: this.currentTetrimino.mat
			},
			this.historyTetriminos,
			this.rowSize,
			this.colSize
		)) {
			this.tsLastFallen = ts;
			return false;
		} else {
			// ok
			this.currentTetrimino.r = nextR;
		}
	}
}

GameState.prototype.hardDropCurrentTetrimino = function(ts) {
	if (this.isPaused || this.isGameOver) {
		return;
	}
	for (let r = this.currentTetrimino.r; r < this.rowSize; r++) {
		if (
			this._isOverlappedWithFloor({
				r: r,
				c: this.currentTetrimino.c,
				type: this.currentTetrimino.type,
				mat: this.currentTetrimino.mat
			}, this.historyTetriminos, this.rowSize, this.colSize)
		) {
			this.currentTetrimino.r = r-1;
			break;
		}
	}

	this.tsLastFallen = ts;
	console.log('Hard-drop complete.');
}

//
GameState.prototype.spinCurrentTetrimino = function(direction) {
	if (this.isPaused || this.isGameOver) {
		return;
	}
	// @Todo.
	// This operation may or may not success.
	// If not success, return false.

	let tmp = [];
	let tetriminoLength = this.currentTetrimino.mat.length;

	// Rotate:
	const rotmap = {
		'l': { '9': L33, '16': L44 },
		'r': { '9': R33, '16': R44 }
	}[direction][tetriminoLength.toString()];

	for (let i = 0; i < tetriminoLength; i++) {
		tmp[i] = this.currentTetrimino.mat[rotmap[i]];
	}

	// @Todo: Check if the tetrimino {r, c, tmp[i]} is out of bound or
	// overlapped with the locked tetriminos.
	// If so, try calibration (wall-kick, floor-kick, etc).
	// @Todo: Calibration. If calibration failed, return false
	// and make no change.
	
	// Replace:
	for (let i = 0; i < tetriminoLength; i++) {
		this.currentTetrimino.mat[i] = tmp[i];
	}
}

// GameState.operateCurrentTetrimino either
// move, spin, or hard-drop the current tetrimino.
//
// @par operation String
//     Either 'move', 'spin', or 'harddrop'.
//
// @par direction String
//     Either 'l', 'r', 'd' when moving,
//     either 'l', 'r' when spining,
//     and be '' when harddropping.
//
// @ret bool
//     Return true if success.
//
GameState.prototype.operateCurrentTetrimino = function(operation, direction, ts) {
	// @Todo.
	if (this.isPaused || this.isGameOver) {
		return;
	}

	switch (operation) {
		case 'move':
		case 'spin':
		case 'harddrop':
	}
}

GameState.prototype._lockCurrentTetrimino = function(ts) {
	//
	// Reset this.tsLastLocked and add the current
	// tetrimino into history tetriminos.
	//
	if (this.isPaused || this.isGameOver) {
		return;
	}
	console.log('Locked at ', ts);
	this.tsLastLocked = ts;

	let tetriminoMatrixSize = (this.currentTetrimino.mat.length === 16) ? 4 : 3;
	console.log('GameState._lockCurr... :: tetMatSz', tetriminoMatrixSize);
	for (let r = 0; r < tetriminoMatrixSize; r++) {
		for (let c = 0; c < tetriminoMatrixSize; c++) {
			if (this.currentTetrimino.mat[r * tetriminoMatrixSize + c] === 1) {
				let realR = this.currentTetrimino.r + r;
				let realC = this.currentTetrimino.c + c;
				console.log(realR, realC);
				this.historyTetriminos[realR][realC] = 1
			}
		}
	}

}

GameState.prototype._spawnNewTetrimino = function(ts) {
	console.log('spawning...');
	if (this.upcomingTetriminoTypes.length === 0) {
		// Generate another sequence of 7-unrepeated tetriminos.
		let seq = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
		let tmp = '';

		// Knuth-Shuffle:
		for (let i = 0; i < seq.length; i++) {
			for (let j = i+1; j < seq.length; j++) {
				if (Math.random() < 0.5) {
					tmp = seq[i];
					seq[i] = seq[j];
					seq[j] = tmp;
				}
			}
		}

		// Append:
		for (let i = 0; i < seq.length; i++) {
			this.upcomingTetriminoTypes.push(seq[i]);
		}
	}

	//
	// Reset this.currentTetrimino.
	//
	let newTetriminoType = this.upcomingTetriminoTypes.pop();

	this.currentTetrimino.r = -1;
	this.currentTetrimino.c = Math.floor(this.colSize / 2) - 1

	this.currentTetrimino.type = newTetriminoType;

	this.currentTetrimino.mat = [];
	for (let i = 0; i < TETRIMINOS[newTetriminoType].length; i++) {
		this.currentTetrimino.mat[i] = TETRIMINOS[newTetriminoType][i];
	}

	this.tsLastSpawned = ts;
	console.log('spawn complete.');
}

// GameState.update updates the info of the game state.
//
// @par ts Number
//     Timestamp given by window.requestAnimationFrame.
//
GameState.prototype.update = function(ts) {
	if (this.isPaused || this.isGameOver) {
		return;
	}

	if (
		this.tsLastFallen > this.tsLastLocked &&
		this.tsLastFallen > this.tsLastSpawned
	) {
		// Just fallen.
		this._lockCurrentTetrimino(ts);
		return;
	}

	if (
		this.tsLastLocked > this.tsLastFallen &&
		this.tsLastLocked > this.tsLastSpawned
	) {
		this._spawnNewTetrimino(ts);
	}

	if (ts - this.tsLastSoftDrop > this.elapsed) {
		this.tsLastSoftDrop = ts;
		this.moveCurrentTetrimino('d', ts);
	}
}

function Renderer(rowSize, colSize) {
	this.elemGameMatrix = document.getElementById('GameMatrix');
	let matrixSize = this.elemGameMatrix.dataset.matrixSize;
	this.rowSize = rowSize;
	this.colSize = colSize;
	this.cells = [];

	this.matrix = newMatrix(this.rowSize, this.colSize, 0);

	this.elemGameMatrix.innerHTML = ''; // fine when efficiency is not critical.
	for (let r = 0; r < this.rowSize; r++) {
		let rowDiv = document.createElement('div');

		this.cells[r] = [];
		for (let c = 0; c < this.colSize; c++) {
			let cellDiv = document.createElement('div');
			this.cells[r][c] = cellDiv;
			rowDiv.appendChild(cellDiv);
		}
		this.elemGameMatrix.appendChild(rowDiv);
	}
}

Renderer.prototype._cleanupMatrix = function(mat, rowSize, colSize) {
	for (let r = 0; r < rowSize; r++) {
		for (let c = 0; c < colSize; c++) {
			mat[r][c] = 0;
		}
	}
}

Renderer.prototype._writeCurrentTetriminoToMatrix = function(currentTetrimino, matrix) {
	let tetriminoMatrixSize = (currentTetrimino.mat.length === 16) ? 4 : 3;
	for (let r = 0; r < tetriminoMatrixSize; r++) {
		for (let c = 0; c < tetriminoMatrixSize; c++) {
			let realR = currentTetrimino.r + r;
			let realC = currentTetrimino.c + c;

			// @Todo: let this be a dictionary instead of being a number.
			if (
				realR >= 0 && realR < this.rowSize &&
				realC >= 0 && realC < this.colSize
			) {
				matrix[realR][realC] = currentTetrimino.mat[
					r * tetriminoMatrixSize + c
				]; 
			}
		}
	}
}

// Render.render renders the game state onto the screen.
//
// @par gameState Object::GameState
//     The GameState.
//
// @par ts Number
//     Timestamp given by window.requestAnimationFrame.
//
Renderer.prototype.render = function(gameState, ts) {
	this._cleanupMatrix(this.matrix, this.rowSize, this.colSize);

	for (let r = 0; r < this.rowSize; r++) {
		for (let c = 0; c < this.colSize; c++) {
			if (gameState.historyTetriminos[r][c] === 1) {
				this.matrix[r][c] = -1;
			}
		}
	}

	this._writeCurrentTetriminoToMatrix(gameState.currentTetrimino, this.matrix);

	for (let r = 0; r < this.rowSize; r++) {
		for (let c = 0; c < this.colSize; c++) {
			this.cells[r][c].classList.remove(
				'active-I', 'active-O', 'active-T',
				'active-S', 'active-Z', 'active-J',
				'active-L',

				'locked-I', 'locked-O', 'locked-T',
				'locked-S', 'locked-Z', 'locked-J',
				'locked-L'
			);
			if (this.matrix[r][c] === 1) {
				this.cells[r][c].classList.add(
					'active-' + gameState.currentTetrimino.type
				);
			} else if (this.matrix[r][c] === -1) {
				this.cells[r][c].classList.add('locked-T');
			}
		}
	}
}

// Event Specification.
//
//     - keypress
// 
function EventHub(keyConfig) {
	this.eventQueue = [];

	this.keyConfig = keyConfig || {
		moveKeys: {
			'A': 'l',
			'D': 'r',
			'S': 'd',
		},
		spinKeys: {
			'J': 'l',
			'K': 'r'
		},
		hardDropKey: 'W',
		pauseToggleKey: ' '
	};

	this._listen();
}

EventHub.prototype._pushEvent = function(eventType, data) {
	this.eventQueue.unshift({
		eventType: eventType,
		timestamp: performance.now(),
		data     : data
	});
}

EventHub.prototype._listen = function() {
	// @Todo
	let _this = this;

	document.body.addEventListener('keydown', function(e) {
		e = e || window.event;
		e = e.keyCode || e.which;

		let key = String.fromCharCode(e);

		if (key === _this.keyConfig.pauseToggleKey) {
			_this._pushEvent('setPauseStatus', 'toggle');
		} else if (key === _this.keyConfig.hardDropKey) {
			_this._pushEvent('hardDropTetrimino', '');
		} else if (_this.keyConfig.moveKeys[key] !== undefined) {
			_this._pushEvent('moveTetrimino', _this.keyConfig.moveKeys[key]);
		} else if (_this.keyConfig.spinKeys[key] !== undefined) {
			_this._pushEvent('spinTetrimino', _this.keyConfig.spinKeys[key]);
		}
	});
}

EventHub.prototype.fetchEvent = function() {
	if (this.eventQueue.length === 0) {
		return null;
	}

	return this.eventQueue.pop();
}

function GameEngine(gameStateConstructor, rendererConstructor, eventHubConstructor, config) {
	this.gameState = new gameStateConstructor(config.rowSize, config.colSize, config.elapsed);
	this.renderer = new rendererConstructor(config.rowSize, config.colSize);
	this.eventHub = new eventHubConstructor(config.keyConfig);

	this.config = config;

	this.tsOffset = 0; // (performance.now() - ts).Set just before requestAnimationFrame starts.
	this.tsLastUpdate = 0;

	this._run();
}

GameEngine.prototype._handleEvents = function(ts) {
	while (true) {
		const gameEvent = this.eventHub.fetchEvent();

		if (gameEvent === null) {
			return;
		}

		console.log(gameEvent);
		switch (gameEvent.eventType) {
			case 'hardDropTetrimino':
				this.gameState.hardDropCurrentTetrimino(ts);
			case 'moveTetrimino':
				this.gameState.moveCurrentTetrimino(gameEvent.data, ts);
				break;
			case 'spinTetrimino':
				this.gameState.spinCurrentTetrimino(gameEvent.data);
				break;
			case 'setPauseStatus':
				this.gameState.setPauseStatus(gameEvent.data, ts + this.tsOffset);
		}
	}
}

GameEngine.prototype._loop = function(ts) {
	this._handleEvents(ts);
	this.gameState.update(ts);
	this.renderer.render(this.gameState, ts);
}

GameEngine.prototype._run = function() {
	this.animationTimestampOffset = performance.now();

	let _this = this;
	(function loopWarpper(ts) {
		_this._loop(ts);
		window.requestAnimationFrame(loopWarpper);
	})();
}

let GE = new GameEngine(GameState, Renderer, EventHub, {
	rowSize: 20,
	colSize: 10,
	elapsed: 1000, // [ms]
	keyConfig: false // Default configuration.
});

</script>
</body>
</html>
