<!doctype html>
<!--

Reference: https://harddrop.com/wiki/Tetris_Wiki

-->

<html>
<head>
	<meta charset="utf8">
	<meta name="viewport" content="width=device-width; initial-scale=1.0">

<style>

#GameContainer {
	display: grid;
	margin-top: 80px;
	place-items: center;
}
#GameMatrix {
	border: 2px solid black;
	border-radius: 5px;
	padding: 3px;
	display: table;
	background: #fff;
}
#GameMatrix>div {
	display: table-row;
}
#GameMatrix>div>div {
	display: table-cell;
	width: 20px;
	height: 20px;
	border: 2px solid white;
}

#GameMatrix>div>div.active-T {
	background-image: linear-gradient(to bottom right, #fdd, #f33);
	border-top-color: #fee;
	border-left-color: #fee;
	border-bottom-color: #f33;
	border-right-color: #f33;
}

#DebugElement {
	border: 2px solid red;
	padding: 5px;
}
</style>
</head>
<body>

<div id='GameContainer'>
	<div id='GameMatrix' data-matrix-size='20x10'>
	</div>

	<pre id='DebugElement'>hello, world</pre>
</div>


<script>

function newMatrix(rowSize, colSize, initValue) {
	let ret = [];

	for (let r = 0; r < rowSize; r++) {
		ret[r] = [];
		for (let c = 0; c < colSize; c++) {
			ret[r][c] = initValue;
		}
	}

	return ret;
}

const TETRIMINOS = {
	I: [
		0, 0, 0, 0,
		1, 1, 1, 1,
		0, 0, 0, 0,
		0, 0, 0, 0
	],
	O: [
		0, 0, 0, 0,
		0, 1, 1, 0,
		0, 1, 1, 0,
		0, 0, 0, 0
	],
	T: [
		0, 1, 0,
		1, 1, 1,
		0, 0, 0
	],
	S: [
		0, 1, 1,
		1, 1, 0,
		0, 0, 0
	],
	Z: [
		1, 1, 0,
		0, 1, 1,
		0, 0, 0
	],
	J: [
		1, 0, 0,
		1, 1, 1,
		0, 0, 0
	],
	L: [
		0, 0, 1,
		1, 1, 1,
		0, 0, 0
	]
};

const L33 = [2, 5, 8, 1, 4, 7, 0, 3, 6]; // conter-clockwise, for tetriminos other than I and O
const R33 = [6, 3, 0, 7, 4, 1, 8, 5, 2]; // L33.reverse();
const L44 = [3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12]; // counter-clockwise, for I and O
const R44 = [12, 8, 4, 0, 13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3];

function GameState(rowSize, colSize) {
	this.currentTetrimino = {
		r: 4,
		c: 4,
		mat: TETRIMINOS['Z']
	};
	this.rowSize = rowSize;
	this.colSize = colSize;
	this.isPaused = false;
	this.isGameOver = false;

	this.historyTetriminos = newMatrix(this.rowSize, this.colSize, 0);
}

GameState.prototype.setPauseStatus = function(command) {
	switch (command) {
		case 'pause':
			this.isPaused = true; break;
		case 'cont':
			this.isPaused = false; break;
		case 'toggle':
			this.isPaused = !this.isPaused; break;
	}
}

GameState.prototype._moveCurrentTetrimino = function(direction) {
	// @Incomplete.
	switch (direction) {
		case 'l':
			this.currentTetrimino.c -= 1;
			break;
		case 'r':
			this.currentTetrimino.c += 1;
			break;
		case 'd':
			this.currentTetrimino.r -= 1;
			break;
	}
}

GameState.prototype._rotateCurrentTetrimino = function(direction) {
	// @Incomplete.
	// This operation may or may not success.
	// If not success, return false.

	let r = [];
	let tetriminoLength = this.currentTetrimino.mat.length;

	// spin:
	const rotmap = {
		'l': { '9': L33, '16': L44 },
		'r': { '9': R33, '16': R44 }
	}[direction][tetriminoLength.toString()];

	for (let i = 0; i < tetriminoLength; i++) {
		r[i] = this.currentTetrimino.mat[rotmap[i]];
	}

	// @Todo: Check if the tetrimino is out of bound or
	// overlapped with the locked tetriminos.
	// If so, try calibration (wall-kick, ground-kick, etc).
	// @Todo: Calibration. If calibration failed, return false
	// and make no change.
	
	for (let i = 0; i < tetriminoLength; i++) {
		this.currentTetrimino.mat[i] = r[i];
	}
}

GameState.prototype.update = function() {
	if (this.isPaused || this.isGameOver) {
		return;
	}

	// @Cleanup: 
	this._moveCurrentTetrimino('r');
}

function Renderer(rowSize, colSize) {
	this.elemGameMatrix = document.getElementById('GameMatrix');
	let matrixSize = this.elemGameMatrix.dataset.matrixSize;
	this.rowSize = rowSize;
	this.colSize = colSize;
	this.cells = [];

	this.matrix = newMatrix(this.rowSize, this.colSize, 0);

	this.elemGameMatrix.innerHTML = ''; // fine when efficiency is not critical.
	for (let r = 0; r < this.rowSize; r++) {
		let rowDiv = document.createElement('div');

		this.cells[r] = [];
		for (let c = 0; c < this.colSize; c++) {
			let cellDiv = document.createElement('div');
			this.cells[r][c] = cellDiv;
			rowDiv.appendChild(cellDiv);
		}
		this.elemGameMatrix.appendChild(rowDiv);
	}
}

Renderer.prototype._cleanupMatrix = function(mat, rowSize, colSize) {
	for (let r = 0; r < rowSize; r++) {
		for (let c = 0; c < colSize; c++) {
			mat[r][c] = 0;
		}
	}
}

Renderer.prototype._writeCurrentTetriminoToMatrix = function(currentTetrimino, matrix) {
	let tetriminoMatrixSize = (currentTetrimino.mat.length === 16) ? 4 : 3;
	for (let r = 0; r < tetriminoMatrixSize; r++) {
		for (let c = 0; c < tetriminoMatrixSize; c++) {
			let realR = currentTetrimino.r + r;
			let realC = currentTetrimino.c + c;

			// @Todo: let this be a dictionary instead of being a number.
			matrix[realR][realC] = currentTetrimino.mat[r * tetriminoMatrixSize + c]; 
		}
	}
}

Renderer.prototype.render = function(gameState) {
	this._cleanupMatrix(this.matrix, this.rowSize, this.colSize);
	this._writeCurrentTetriminoToMatrix(gameState.currentTetrimino, this.matrix);

	for (let r = 0; r < this.rowSize; r++) {
		for (let c = 0; c < this.colSize; c++) {
			this.cells[r][c].classList.remove('active-T');
			if (this.matrix[r][c] === 1) {
				this.cells[r][c].classList.add('active-T');
			}
		}
	}
}

// Event Specification.
//
//     - keypress
// 
function EventHub(keyConfig) {
	this.eventQueue = [];

	this.keyConfig = keyConfig || {
		moveLeft: 'A',
		moveRight: 'D',
		moveDown: 'S',
		hardDrop: 'W',

		rotateLeft: 'J',
		rotateRight: 'K'
	};

	this._listen();
}

EventHub.prototype._pushEvent = function(eventType, data) {
	this.eventQueue.unshift({
		eventType: eventType,
		timestamp: performance.now(),
		data     : data
	});
}

EventHub.prototype._listen = function() {
	// @Incomplete

	// @Todo: Key binding according to this.keyConfig.
}

EventHub.prototype.fetchEvent = function() {
	if (this.eventQueue.length === 0) {
		return null;
	}

	return this.eventQueue.pop();
}

function GameEngine() {
}

GameEngine.prototype._handleEvents = function() {
}

// --debug--

let GS = new GameState(20, 10);
let R = new Renderer(20, 10);
GS.update();
R.render(GS);




</script>
</body>
</html>
